// src/parse/scantiger.cc generated by reflex 3.2.12 from src/parse/scantiger.ll

#define REFLEX_VERSION "3.2.12"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_YYLTYPE
#undef REFLEX_OPTION_YYSTYPE
#undef REFLEX_OPTION_bison_cc
#undef REFLEX_OPTION_bison_cc_namespace
#undef REFLEX_OPTION_bison_cc_parser
#undef REFLEX_OPTION_bison_complete
#undef REFLEX_OPTION_bison_locations
#undef REFLEX_OPTION_debug
#undef REFLEX_OPTION_flex
#undef REFLEX_OPTION_header_file
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_noyywrap
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_params
#undef REFLEX_OPTION_prefix
#undef REFLEX_OPTION_token_eof
#undef REFLEX_OPTION_token_type

#define REFLEX_OPTION_YYLTYPE             parse::location
#define REFLEX_OPTION_YYSTYPE             parse::parser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  parse
#define REFLEX_OPTION_bison_cc_parser     parser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_debug               true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_header_file         "src/parse/scantiger.hh"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           parse
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "src/parse/scantiger.cc"
#define REFLEX_OPTION_params              ::parse::TigerParser& tp
#define REFLEX_OPTION_prefix              yy
#define REFLEX_OPTION_token_eof           parse::parser::symbol_type(0, location())
#define REFLEX_OPTION_token_type          parse::parser::symbol_type

// --debug option enables ASSERT:
#define ASSERT(c) assert(c)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 17 "src/parse/scantiger.ll"


#define YY_EXTERN_C extern "C" // For linkage rule

#include <cerrno>
#include <climits>
#include <regex>
#include <string>

#include <boost/lexical_cast.hpp>

#include <misc/contract.hh>
  // Using misc::escape is very useful to quote non printable characters.
  // For instance
  //
  //    std::cerr << misc::escape('\n') << '\n';
  //
  // reports about `\n' instead of an actual new-line character.
#include <misc/escape.hh>
#include <misc/symbol.hh>
#include <parse/parsetiger.hh>
#include <parse/tiger-parser.hh>

  // FIXME: Some code was deleted here (Define YY_USER_ACTION to update locations).
/*DONE*/
#define YY_USER_ACTION \
    tp.location_.columns(size());


#define TOKEN(Type)                             \
  parser::make_ ## Type(tp.location_)

#define TOKEN_VAL(Type, Value)                  \
  parser::make_ ## Type(Value, tp.location_)

# define CHECK_EXTENSION()                              \
  do {                                                  \
    if (!tp.enable_extensions_p_)                       \
      tp.error_ << misc::error::error_type::scan        \
                << tp.location_                         \
                << ": invalid identifier: `"            \
                << misc::escape(text()) << "'\n";       \
  } while (false)



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define SC_COMMENT (1)
#define SC_STRING (2)
#define YY_NUM_RULES (77)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>

namespace parse {

typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

} // namespace parse

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace parse {

class Lexer : public FlexLexer {
#line 76 "src/parse/scantiger.ll"

// FIXME: Some code was deleted here (Local variables).
/*DONE*/
int nb_comment = 0;
std::string growing_string = "";
long ouais = 0;

 public:
  Lexer(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, NULL means std::cout by default
      std::ostream *os = NULL)
    :
      FlexLexer(input, os)
  {
    set_debug(true);
  }
  std::string filename;
  // bison-complete bison-locations: location() returns lexeme location
  virtual parse::location location(void)
  {
    parse::location yylloc;
    yylloc.begin.filename = &filename;
    yylloc.begin.line = static_cast<unsigned int>(matcher().lineno());
    yylloc.begin.column = static_cast<unsigned int>(matcher().columno());
    yylloc.end.filename = &filename;
    yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end());
    yylloc.end.column = static_cast<unsigned int>(matcher().columno_end());
    return yylloc;
  }
  virtual parse::parser::symbol_type yylex(void)
  {
    LexerError("Lexer::yylex invoked but %option lex=lex is used");
    yyterminate();
  }
  // the flex bison-complete lexer function defined by SECTION 2
  virtual parse::parser::symbol_type lex(::parse::TigerParser& tp);
};

} // namespace parse

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "src/parse/scantiger.ll"
/* -*- C++ -*- */
// %option defines the parameters with which the reflex will be launched
#line 4 "src/parse/scantiger.ll"
// To enable compatibility with bison
#line 11 "src/parse/scantiger.ll"
// Add a param of function lex() generate in Lexer class
#line 14 "src/parse/scantiger.ll"
// Name of the class generate by reflex
#line 65 "src/parse/scantiger.ll"
/* Abbreviations.  */

#line 67 "src/parse/scantiger.ll"
/* FIXME: Some code was deleted here. */
/*DONE*/


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

parse::parser::symbol_type parse::Lexer::lex(::parse::TigerParser& tp)
{
  static const char *REGEX_INITIAL = "(?m)((?:\\Qarray\\E))|((?:\\Q&\\E))|((?:\\Q:=\\E))|((?:\\Qbreak\\E))|((?:\\Q_cast\\E))|((?:\\Qclass\\E))|((?:\\Q:\\E))|((?:\\Q,\\E))|((?:\\Q/\\E))|((?:\\Qdo\\E))|((?:\\Q.\\E))|((?:\\Qelse\\E))|((?:\\Qend\\E))|((?:\\Q=\\E))|((?:\\Qextends\\E))|((?:\\Qfor\\E))|((?:\\Qfunction\\E))|((?:\\Q>=\\E))|((?:\\Q>\\E))|((?:\\Qif\\E))|((?:\\Qimport\\E))|((?:\\Qin\\E))|((?:\\Q{\\E))|((?:\\Q[\\E))|((?:\\Q<=\\E))|((?:\\Qlet\\E))|((?:\\Q(\\E))|((?:\\Q<\\E))|((?:\\Q-\\E))|((?:\\Qmethod\\E))|((?:\\Q<>\\E))|((?:\\Qnew\\E))|((?:\\Qnil\\E))|((?:\\Qof\\E))|((?:\\Q|\\E))|((?:\\Q+\\E))|((?:\\Qprimitive\\E))|((?:\\Q}\\E))|((?:\\Q]\\E))|((?:\\Q)\\E))|((?:\\Q;\\E))|((?:\\Qthen\\E))|((?:\\Q*\\E))|((?:\\Qto\\E))|((?:\\Qtype\\E))|((?:\\Qvar\\E))|((?:\\Qwhile\\E))|((?:[0-9]+;))|((?:[A-\\x5ba-z][0-9A-Z_a-z]*|(?:\\Q_main\\E)];))|((?:[A-Za-z]+;))|((?:[\\x09\\x20]))|(\\n)|(\\r)|(\\r\\n)|(\\n\\r)|((?:\\Q/*\\E))|((?:\\Q\"\\E))";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  static const char *REGEX_SC_COMMENT = "(?m)((?:\\Q/*\\E))|([^\\x2a]*)|((?:\\Q*\\E)+[^\\x2a/]*)|((?:\\Q*/\\E))";
  static const reflex::Pattern PATTERN_SC_COMMENT(REGEX_SC_COMMENT);
  static const char *REGEX_SC_STRING = "(?m)((?:\\Q\"\\E))|((?:\\Q\\a\\E))|((?:\\Q\\b\\E))|((?:\\Q\\f\\E))|((?:\\Q\\n\\E))|((?:\\Q\\r\\E))|((?:\\Q\\t\\E))|((?:\\Q\\v\\E))|(\\\\[0-7]{3})|(\\\\x[0-9A-Fa-f]{2})|((?:\\Q\\\\.\\E))|((?:\\Q.\\E))";
  static const reflex::Pattern PATTERN_SC_STRING(REGEX_SC_STRING);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  switch (start())
  {
    case INITIAL:
#line 86 "src/parse/scantiger.ll"
/* The rules. */
/* FIXME: Some code was deleted here. */
#line 89 "src/parse/scantiger.ll"
/*FIXED on going*/

    break;
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule src/parse/scantiger.ll:139\033[0m start(" << start() << ")\n";
#line 139 "src/parse/scantiger.ll"
return TOKEN(EOF      );

            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31mdefault rule\033[0m\n";
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule src/parse/scantiger.ll:89: "array" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:89\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 89 "src/parse/scantiger.ll"
return parser::make_ARRAY(tp.location_);
            YY_BREAK
          case 2: // rule src/parse/scantiger.ll:90: "&" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:90\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 90 "src/parse/scantiger.ll"
return TOKEN(AND);
            YY_BREAK
          case 3: // rule src/parse/scantiger.ll:91: ":=" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:91\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 91 "src/parse/scantiger.ll"
return TOKEN(ASSIGN);
            YY_BREAK
          case 4: // rule src/parse/scantiger.ll:92: "break" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:92\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 92 "src/parse/scantiger.ll"
return TOKEN(BREAK    );
            YY_BREAK
          case 5: // rule src/parse/scantiger.ll:93: "_cast" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:93\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 93 "src/parse/scantiger.ll"
return TOKEN(CAST     );
            YY_BREAK
          case 6: // rule src/parse/scantiger.ll:94: "class" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:94\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 94 "src/parse/scantiger.ll"
return TOKEN(CLASS    );
            YY_BREAK
          case 7: // rule src/parse/scantiger.ll:95: ":" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:95\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 95 "src/parse/scantiger.ll"
return TOKEN(COLON    );

            YY_BREAK
          case 8: // rule src/parse/scantiger.ll:97: "," :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:97\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 97 "src/parse/scantiger.ll"
return TOKEN(COMMA    );
            YY_BREAK
          case 9: // rule src/parse/scantiger.ll:98: "/" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:98\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 98 "src/parse/scantiger.ll"
return TOKEN(DIVIDE   );
            YY_BREAK
          case 10: // rule src/parse/scantiger.ll:99: "do" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:99\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 99 "src/parse/scantiger.ll"
return TOKEN(DO       );
            YY_BREAK
          case 11: // rule src/parse/scantiger.ll:100: "." :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:100\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 100 "src/parse/scantiger.ll"
return TOKEN(DOT      );

            YY_BREAK
          case 12: // rule src/parse/scantiger.ll:102: "else" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:102\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 102 "src/parse/scantiger.ll"
return TOKEN(ELSE     );
            YY_BREAK
          case 13: // rule src/parse/scantiger.ll:103: "end" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:103\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 103 "src/parse/scantiger.ll"
return TOKEN(END      );
            YY_BREAK
          case 14: // rule src/parse/scantiger.ll:104: "=" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:104\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 104 "src/parse/scantiger.ll"
return TOKEN(EQ       );
            YY_BREAK
          case 15: // rule src/parse/scantiger.ll:105: "extends" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:105\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 105 "src/parse/scantiger.ll"
return TOKEN(EXTENDS  );
            YY_BREAK
          case 16: // rule src/parse/scantiger.ll:106: "for" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:106\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 106 "src/parse/scantiger.ll"
return TOKEN(FOR      );
            YY_BREAK
          case 17: // rule src/parse/scantiger.ll:107: "function" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:107\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 107 "src/parse/scantiger.ll"
return TOKEN(FUNCTION );
            YY_BREAK
          case 18: // rule src/parse/scantiger.ll:108: ">=" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:108\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 108 "src/parse/scantiger.ll"
return TOKEN(GE       );
            YY_BREAK
          case 19: // rule src/parse/scantiger.ll:109: ">" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:109\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 109 "src/parse/scantiger.ll"
return TOKEN(GT       );
            YY_BREAK
          case 20: // rule src/parse/scantiger.ll:110: "if" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:110\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 110 "src/parse/scantiger.ll"
return TOKEN(IF       );
            YY_BREAK
          case 21: // rule src/parse/scantiger.ll:111: "import" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:111\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 111 "src/parse/scantiger.ll"
return TOKEN(IMPORT   );
            YY_BREAK
          case 22: // rule src/parse/scantiger.ll:112: "in" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:112\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 112 "src/parse/scantiger.ll"
return TOKEN(IN       );
            YY_BREAK
          case 23: // rule src/parse/scantiger.ll:113: "{" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:113\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 113 "src/parse/scantiger.ll"
return TOKEN(LBRACE   );
            YY_BREAK
          case 24: // rule src/parse/scantiger.ll:114: "[" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:114\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 114 "src/parse/scantiger.ll"
return TOKEN(LBRACK   );
            YY_BREAK
          case 25: // rule src/parse/scantiger.ll:115: "<=" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:115\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 115 "src/parse/scantiger.ll"
return TOKEN(LE       );
            YY_BREAK
          case 26: // rule src/parse/scantiger.ll:116: "let" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:116\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 116 "src/parse/scantiger.ll"
return TOKEN(LET      );
            YY_BREAK
          case 27: // rule src/parse/scantiger.ll:117: "(" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:117\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 117 "src/parse/scantiger.ll"
return TOKEN(LPAREN   );

            YY_BREAK
          case 28: // rule src/parse/scantiger.ll:119: "<" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:119\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 119 "src/parse/scantiger.ll"
return TOKEN(LT       );
            YY_BREAK
          case 29: // rule src/parse/scantiger.ll:120: "-" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:120\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 120 "src/parse/scantiger.ll"
return TOKEN(MINUS    );
            YY_BREAK
          case 30: // rule src/parse/scantiger.ll:121: "method" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:121\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 121 "src/parse/scantiger.ll"
return TOKEN(METHOD   );
            YY_BREAK
          case 31: // rule src/parse/scantiger.ll:122: "<>" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:122\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 122 "src/parse/scantiger.ll"
return TOKEN(NE       );
            YY_BREAK
          case 32: // rule src/parse/scantiger.ll:123: "new" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:123\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 123 "src/parse/scantiger.ll"
return TOKEN(NEW      );
            YY_BREAK
          case 33: // rule src/parse/scantiger.ll:124: "nil" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:124\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 124 "src/parse/scantiger.ll"
return TOKEN(NIL      );
            YY_BREAK
          case 34: // rule src/parse/scantiger.ll:125: "of" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:125\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 125 "src/parse/scantiger.ll"
return TOKEN(OF       );
            YY_BREAK
          case 35: // rule src/parse/scantiger.ll:126: "|" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:126\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 126 "src/parse/scantiger.ll"
return TOKEN(OR       );
            YY_BREAK
          case 36: // rule src/parse/scantiger.ll:127: "+" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:127\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 127 "src/parse/scantiger.ll"
return TOKEN(PLUS     );
            YY_BREAK
          case 37: // rule src/parse/scantiger.ll:128: "primitive" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:128\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 128 "src/parse/scantiger.ll"
return TOKEN(PRIMITIVE);
            YY_BREAK
          case 38: // rule src/parse/scantiger.ll:129: "}" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:129\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 129 "src/parse/scantiger.ll"
return TOKEN(RBRACE   );
            YY_BREAK
          case 39: // rule src/parse/scantiger.ll:130: "]" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:130\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 130 "src/parse/scantiger.ll"
return TOKEN(RBRACK   );
            YY_BREAK
          case 40: // rule src/parse/scantiger.ll:131: ")" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:131\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 131 "src/parse/scantiger.ll"
return TOKEN(RPAREN   );
            YY_BREAK
          case 41: // rule src/parse/scantiger.ll:132: ";" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:132\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 132 "src/parse/scantiger.ll"
return TOKEN(SEMI     );
            YY_BREAK
          case 42: // rule src/parse/scantiger.ll:133: "then" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:133\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 133 "src/parse/scantiger.ll"
return TOKEN(THEN     );
            YY_BREAK
          case 43: // rule src/parse/scantiger.ll:134: "*" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:134\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 134 "src/parse/scantiger.ll"
return TOKEN(TIMES    );
            YY_BREAK
          case 44: // rule src/parse/scantiger.ll:135: "to" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:135\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 135 "src/parse/scantiger.ll"
return TOKEN(TO       );
            YY_BREAK
          case 45: // rule src/parse/scantiger.ll:136: "type" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:136\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 136 "src/parse/scantiger.ll"
return TOKEN(TYPE     );
            YY_BREAK
          case 46: // rule src/parse/scantiger.ll:137: "var" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:137\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 137 "src/parse/scantiger.ll"
return TOKEN(VAR      );
            YY_BREAK
          case 47: // rule src/parse/scantiger.ll:138: "while" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:138\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 138 "src/parse/scantiger.ll"
return TOKEN(WHILE    );
            YY_BREAK
          case 48: // rule src/parse/scantiger.ll:141: {int} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:141\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 141 "src/parse/scantiger.ll"
{
        int val = 0;
    //FIXME:Some code was deleted here (Decode, and check the value).
                return TOKEN_VAL(INT, val);
      }

            YY_BREAK
          case 49: // rule src/parse/scantiger.ll:147: {id} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:147\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 147 "src/parse/scantiger.ll"
return TOKEN_VAL(ID, text());

            YY_BREAK
          case 50: // rule src/parse/scantiger.ll:149: {string} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:149\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 149 "src/parse/scantiger.ll"
return TOKEN_VAL(ID, text());

            YY_BREAK
          case 51: // rule src/parse/scantiger.ll:151: {space} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:151\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 151 "src/parse/scantiger.ll"
tp.location_.columns();

            YY_BREAK
          case 52: // rule src/parse/scantiger.ll:154: \n :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:154\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 154 "src/parse/scantiger.ll"
{ tp.location_.lines();
tp.location_.end.column = 0;
}

            YY_BREAK
          case 53: // rule src/parse/scantiger.ll:158: \r :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:158\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 158 "src/parse/scantiger.ll"
{ tp.location_.lines();
tp.location_.end.column = 0;
}

            YY_BREAK
          case 54: // rule src/parse/scantiger.ll:162: \r\n :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:162\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 162 "src/parse/scantiger.ll"
{
    tp.location_.lines();
    tp.location_.end.column = 0;
}

            YY_BREAK
          case 55: // rule src/parse/scantiger.ll:167: \n\r :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:167\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 167 "src/parse/scantiger.ll"
{ tp.location_.lines();
tp.location_.end.column = 0;
}


            YY_BREAK
          case 56: // rule src/parse/scantiger.ll:172: "/*" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:172\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 172 "src/parse/scantiger.ll"
{
    nb_comment++;
    growing_string.clear();
    start(SC_COMMENT);
}

            YY_BREAK
          case 57: // rule src/parse/scantiger.ll:178: "\"" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:178\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 178 "src/parse/scantiger.ll"
{
    growing_string.clear();
    start(SC_STRING);;
}


            YY_BREAK
        }
        break;
      case SC_COMMENT:
        matcher().pattern(PATTERN_SC_COMMENT);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule src/parse/scantiger.ll:139\033[0m start(" << start() << ")\n";
#line 139 "src/parse/scantiger.ll"
return TOKEN(EOF      );

            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31mdefault rule\033[0m\n";
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule src/parse/scantiger.ll:187: "/*" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:187\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 187 "src/parse/scantiger.ll"
{nb_comment++;}

            YY_BREAK
          case 2: // rule src/parse/scantiger.ll:189: [^*]* :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:189\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 189 "src/parse/scantiger.ll"


            YY_BREAK
          case 3: // rule src/parse/scantiger.ll:191: "*"+[^*/]* :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:191\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 191 "src/parse/scantiger.ll"


            YY_BREAK
          case 4: // rule src/parse/scantiger.ll:193: "*/" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:193\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 193 "src/parse/scantiger.ll"
{
     nb_comment--;
     if (nb_comment == 0)
     start(INITIAL);
     else
     do {
         tp.error_ << misc::error::error_type::scan        \
         << tp.location_                                 \
         << "comment never end"                          \
         << misc::escape(text()) << "'\n"               \
         << nb_comment;                                 \
     } while (false);
     start(INITIAL);
}

            YY_BREAK
        }
        break;
      case SC_STRING:
        matcher().pattern(PATTERN_SC_STRING);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule src/parse/scantiger.ll:139\033[0m start(" << start() << ")\n";
#line 139 "src/parse/scantiger.ll"
return TOKEN(EOF      );

            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31mdefault rule\033[0m\n";
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule src/parse/scantiger.ll:219: "\"" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:219\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 219 "src/parse/scantiger.ll"
{start(INITIAL);}
            YY_BREAK
          case 2: // rule src/parse/scantiger.ll:220: "\a" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:220\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 220 "src/parse/scantiger.ll"
{growing_string = growing_string + '\a';}
            YY_BREAK
          case 3: // rule src/parse/scantiger.ll:221: "\b" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:221\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 221 "src/parse/scantiger.ll"
{growing_string = growing_string + '\b';}
            YY_BREAK
          case 4: // rule src/parse/scantiger.ll:222: "\f" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:222\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 222 "src/parse/scantiger.ll"
{growing_string = growing_string + '\f';}
            YY_BREAK
          case 5: // rule src/parse/scantiger.ll:223: "\n" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:223\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 223 "src/parse/scantiger.ll"
{growing_string = growing_string + '\n';}
            YY_BREAK
          case 6: // rule src/parse/scantiger.ll:224: "\r" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:224\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 224 "src/parse/scantiger.ll"
{growing_string = growing_string + '\r';}
            YY_BREAK
          case 7: // rule src/parse/scantiger.ll:225: "\t" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:225\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 225 "src/parse/scantiger.ll"
{growing_string = growing_string + '\t';}
            YY_BREAK
          case 8: // rule src/parse/scantiger.ll:226: "\v" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:226\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 226 "src/parse/scantiger.ll"
{growing_string = growing_string + '\v';}

            YY_BREAK
          case 9: // rule src/parse/scantiger.ll:228: \\[0-7]{3} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:228\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 228 "src/parse/scantiger.ll"
{
        ouais += strtol(text() + 1, 0, 8);
        do {
        if (ouais > 255)
            tp.error_ << misc::error::error_type::scan        \
            << tp.location_                                   \
            << "wring octal\n"                                \
            << misc::escape(text()) << "'\n";                 \
        } while (false);
        start(INITIAL);

    }

            YY_BREAK
          case 10: // rule src/parse/scantiger.ll:241: \\x[0-9a-fA-F]{2} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:241\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 241 "src/parse/scantiger.ll"
{
  growing_string += strtol(text() + 2, 0, 16);

}

            YY_BREAK
          case 11: // rule src/parse/scantiger.ll:246: "\\." :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:246\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 246 "src/parse/scantiger.ll"
{
    do {
            tp.error_ << misc::error::error_type::scan        \
            << tp.location_                                   \
            << "wring octal\n"                                \
            << misc::escape(text()) << "'\n";                 \
        } while (false);
    start(INITIAL);
}

            YY_BREAK
          case 12: // rule src/parse/scantiger.ll:256: "." :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:256\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 256 "src/parse/scantiger.ll"
{growing_string = growing_string + text();}
            YY_BREAK
        }
        break;
      default:
        start(0);
    }
  }
}
